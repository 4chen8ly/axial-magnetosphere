class c{constructor(t="TasteOS_DB",e="vectors"){this.dbName=t,this.storeName=e,this.db=null}async init(){return new Promise((t,e)=>{const n=indexedDB.open(this.dbName,1);n.onerror=r=>e("VectorDB init failed"),n.onupgradeneeded=r=>{const s=r.target.result;s.objectStoreNames.contains(this.storeName)||s.createObjectStore(this.storeName,{keyPath:"id"}).createIndex("timestamp","timestamp",{unique:!1})},n.onsuccess=r=>{this.db=r.target.result,t()}})}async add(t){return t.vector&&(t.vector=this.normalize(t.vector)),this.performTransaction("readwrite",e=>e.put(t))}async get(t){return this.performTransaction("readonly",e=>e.get(t))}async getAll(){return this.performTransaction("readonly",t=>t.getAll())}async performTransaction(t,e){return new Promise((n,r)=>{const a=this.db.transaction([this.storeName],t).objectStore(this.storeName),o=e(a);o.onsuccess=()=>n(o.result),o.onerror=()=>r(o.error)})}normalize(t){let e=0;for(let s=0;s<t.length;s++)e+=t[s]*t[s];const n=Math.sqrt(e);if(n===0)return t;const r=new Float32Array(t.length);for(let s=0;s<t.length;s++)r[s]=t[s]/n;return r}cosineSimilarity(t,e){let n=0;for(let r=0;r<t.length;r++)n+=t[r]*e[r];return n}}export{c as V};
